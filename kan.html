<!DOCTYPE html>
<html lang="kn">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; font-src 'self' *; media-stream 'self'; connect-src 'self' https://libretranslate.com;">
  <title>‡≤ï‡≥ç‡≤∞‡≥Ü‡≤°‡≤ø‡≤ü‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø‡≤Æ‡≤æ‡≤™‡≤® - ‡≤ï‡≤®‡≥ç‡≤®‡≤°</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="intro-screen">
    <h1>‡≤ï‡≥ç‡≤∞‡≥Ü‡≤°‡≤ø‡≤ü‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø‡≤Æ‡≤æ‡≤™‡≤®</h1>
    <p>‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≥ã‡≤£...</p>
  </div>

  <div class="main-container">
    <div class="controls">
      <button onclick="window.location.href='index.html'">X</button>
    </div>
    <h2>‡≤ï‡≥ç‡≤∞‡≥Ü‡≤°‡≤ø‡≤ü‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø‡≤Æ‡≤æ‡≤™‡≤® ‡≤∏‡≤π‡≤æ‡≤Ø‡≤ï</h2>
    <video id="video" autoplay muted playsinline></video>
    <canvas id="visualizer"></canvas>

    <div class="chat-container" id="chatContainer"></div>

    <div class="chat-input" id="chatInputSection">
      <div class="chat-input-container">
        <input type="text" id="chatInput" placeholder="‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤â‡≤§‡≥ç‡≤§‡≤∞‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø (‡≤ê‡≤ö‡≥ç‡≤õ‡≤ø‡≤ï)">
        <button id="micBtn">üéôÔ∏è</button>
        <button id="rehearBtn">üîÑ</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    let analyser, dataArray, audioContext, source;
    let audioStream, animationId;
    let recognition;
    let isSpeaking = false;
    let lastTranscript = '';
    let currentQuestionIndex = 0;
    let responses = [];
    let isAsking = false;
    let audioElement = new Audio();
    
    // Voice analysis variables
    let voiceConfidenceScores = [];
    let mediaRecorder;
    let audioChunks = [];

    const questions = [
      "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤π‡≥Ü‡≤∏‡≤∞‡≥Å ‡≤è‡≤®‡≥Å?",
      "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≥ç‡≤∞‡≤∏‡≥ç‡≤§‡≥Å‡≤§ ‡≤â‡≤¶‡≥ç‡≤Ø‡≥ã‡≤ó ‡≤∏‡≥ç‡≤•‡≤ø‡≤§‡≤ø ‡≤è‡≤®‡≥Å?",
      "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤µ‡≤æ‡≤∞‡≥ç‡≤∑‡≤ø‡≤ï ‡≤Ü‡≤¶‡≤æ‡≤Ø ‡≤é‡≤∑‡≥ç‡≤ü‡≥Å?",
      "‡≤®‡≤ø‡≤Æ‡≤ó‡≥Ü ‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤Ö‡≤∏‡≥ç‡≤§‡≤ø‡≤§‡≥ç‡≤µ‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø‡≤∞‡≥Å‡≤µ ‡≤∏‡≤æ‡≤≤‡≤ó‡≤≥‡≥Å ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤¨‡≤æ‡≤ï‡≤ø‡≤ó‡≤≥‡≤ø‡≤µ‡≥Ü‡≤Ø‡≥á?",
      "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤ï‡≥ç‡≤∞‡≥Ü‡≤°‡≤ø‡≤ü‡≥ç ‡≤∏‡≥ç‡≤ï‡≥ã‡≤∞‡≥ç ‡≤é‡≤∑‡≥ç‡≤ü‡≥Å, ‡≤§‡≤ø‡≤≥‡≤ø‡≤¶‡≤ø‡≤¶‡≥ç‡≤¶‡≤∞‡≥Ü?",
      "‡≤®‡≥Ä‡≤µ‡≥Å ‡≤¨‡≤Ø‡≤∏‡≥Å‡≤µ ‡≤ï‡≥ç‡≤∞‡≥Ü‡≤°‡≤ø‡≤ü‡≥ç‚Äå‡≤® ‡≤â‡≤¶‡≥ç‡≤¶‡≥á‡≤∂ ‡≤è‡≤®‡≥Å?",
      "‡≤é‡≤∑‡≥ç‡≤ü‡≥Å ‡≤ï‡≥ç‡≤∞‡≥Ü‡≤°‡≤ø‡≤ü‡≥ç ‡≤¨‡≥á‡≤°‡≤ø‡≤ï‡≥ä‡≤≥‡≥ç‡≤≥‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥ç‡≤¶‡≥Ä‡≤∞‡≤ø?",
      "‡≤®‡≥Ä‡≤µ‡≥Å ‡≤™‡≥ç‡≤∞‡≤∏‡≥ç‡≤§‡≥Å‡≤§ ‡≤µ‡≤æ‡≤∏‡≤ø‡≤∏‡≥Å‡≤µ ‡≤Æ‡≤®‡≥Ü‡≤Ø ‡≤Æ‡≤æ‡≤≤‡≥Ä‡≤ï‡≤∞‡≥á ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤¨‡≤æ‡≤°‡≤ø‡≤ó‡≥Ü‡≤¶‡≤æ‡≤∞‡≤∞‡≥á?",
      "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≥ç‡≤∞‡≤∏‡≥ç‡≤§‡≥Å‡≤§ ‡≤â‡≤¶‡≥ç‡≤Ø‡≥ã‡≤ó‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤é‡≤∑‡≥ç‡≤ü‡≥Å ‡≤ï‡≤æ‡≤≤‡≤¶‡≤ø‡≤Ç‡≤¶‡≤ø‡≤∞‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥ç‡≤¶‡≥Ä‡≤∞‡≤ø?",
      "‡≤®‡≤ø‡≤Æ‡≤ó‡≥Ü ‡≤π‡≥Ü‡≤ö‡≥ç‡≤ö‡≥Å‡≤µ‡≤∞‡≤ø ‡≤Ü‡≤¶‡≤æ‡≤Ø‡≤¶ ‡≤Æ‡≥Ç‡≤≤‡≤ó‡≤≥‡≤ø‡≤µ‡≥Ü‡≤Ø‡≥á?"
    ];

    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
      recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.lang = 'kn-IN';
      recognition.continuous = true;
      recognition.interimResults = true;
    } else {
      appendMessage("‡≤à ‡≤¨‡≥ç‡≤∞‡≥å‡≤∏‡≤∞‡≥ç‚Äå‡≤®‡≤≤‡≥ç‡≤≤‡≤ø ‡≤∏‡≥ç‡≤™‡≥Ä‡≤ö‡≥ç ‡≤∞‡≥Ü‡≤ï‡≤ó‡≥ç‡≤®‡≤ø‡≤∑‡≤®‡≥ç ‡≤¨‡≥Ü‡≤Ç‡≤¨‡≤≤‡≤ø‡≤§‡≤µ‡≤æ‡≤ó‡≤ø‡≤≤‡≥ç‡≤≤. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å Google Chrome ‡≤Ö‡≤•‡≤µ‡≤æ Edge ‡≤¨‡≤≥‡≤∏‡≤ø.", 'error');
    }

    if ('speechSynthesis' in window) {
      window.speechSynthesis.onvoiceschanged = () => {
        const voices = window.speechSynthesis.getVoices();
        console.log("Available voices:", voices.map(v => `${v.name} (${v.lang})`));
      };
    } else {
      appendMessage("‡≤ü‡≥Ü‡≤ï‡≥ç‡≤∏‡≥ç‡≤±‡≥ç‡≤±‡≥ç-‡≤ü‡≥Å-‡≤∏‡≥ç‡≤™‡≥Ä‡≤ö‡≥ç ‡≤à ‡≤¨‡≥ç‡≤∞‡≥å‡≤∏‡≤∞‡≥ç‚Äå‡≤®‡≤≤‡≥ç‡≤≤‡≤ø ‡≤≤‡≤≠‡≥ç‡≤Ø‡≤µ‡≤ø‡≤≤‡≥ç‡≤≤.", 'error');
    }

    // Voice recording functions
    async function startVoiceRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };
        
        mediaRecorder.start();
        console.log("Voice recording started");
      } catch (error) {
        console.error("Error starting voice recording:", error);
      }
    }

    function stopVoiceRecording() {
      return new Promise((resolve) => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            const confidenceScore = await analyzeVoiceTone(audioBlob);
            voiceConfidenceScores.push(confidenceScore);
            console.log(`Voice confidence score: ${confidenceScore}`);
            resolve(confidenceScore);
          };
          mediaRecorder.stop();
        } else {
          resolve(0.5); // Default confidence if recording failed
        }
      });
    }

    async function analyzeVoiceTone(audioBlob) {
      try {
        // Convert audio to base64
        const arrayBuffer = await audioBlob.arrayBuffer();
        const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
        
        // Send to Flask API for analysis
        const response = await fetch('/api/analyze-voice', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            audio_data: base64Audio,
            audio_format: 'wav'
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          return result.confidence_score;
        } else {
          console.error('Voice analysis failed:', response.statusText);
          return 0.5; // Default confidence
        }
      } catch (error) {
        console.error('Error analyzing voice tone:', error);
        return 0.5; // Default confidence
      }
    }

    // Translation function using LibreTranslate
    async function translateToEnglish(kannadaText) {
      try {
        const response = await fetch('https://libretranslate.com/translate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            q: kannadaText,
            source: 'kn',
            target: 'en'
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          console.log(`Translated: "${kannadaText}" ‚Üí "${result.translatedText}"`);
          return result.translatedText;
        } else {
          console.error('Translation failed:', response.statusText);
          return kannadaText; // Return original if translation fails
        }
      } catch (error) {
        console.error('Error translating text:', error);
        return kannadaText; // Return original if translation fails
      }
    }

    function visualize() {
      analyser.getByteTimeDomainData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      gradient.addColorStop(0, '#4a4aff');
      gradient.addColorStop(1, '#8a8aff');
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = gradient;

      let sliceWidth = canvas.width * 1.0 / dataArray.length;
      let x = 0;
      for (let i = 0; i < dataArray.length; i++) {
        let v = dataArray[i] / 128.0;
        let y = v * canvas.height / 2;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        x += sliceWidth;
      }
      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();
      animationId = requestAnimationFrame(visualize);
    }

    async function speakQuestion(text) {
      return new Promise((resolve) => {
        isAsking = true;
        // Stop recognition while asking question
        if (recognition && isSpeaking) {
          recognition.stop();
        }
        
        const questionNumber = currentQuestionIndex + 1;
        const audioFile = questionNumber === 1 ? 'audio/kannada/q1kancompress.m4a' : `audio/kannada/q${questionNumber}.m4a`;
        console.log("Loading audio file:", audioFile);
        
        // Reset audio element
        audioElement.pause();
        audioElement.currentTime = 0;
        audioElement.src = audioFile;
        
        audioElement.onloadeddata = () => {
          console.log("Audio file loaded successfully");
        };

        audioElement.onended = () => {
          console.log("Audio playback completed");
          // Add 1 second buffer before accepting input
          setTimeout(() => {
            isAsking = false;
            console.log("Now accepting input");
            // Restart recognition after question is done
            if (recognition && !isSpeaking) {
              recognition.start();
            }
            resolve();
          }, 1000);
        };
        
        audioElement.onerror = (error) => {
          console.error("Audio playback error:", error);
          console.error("Audio error code:", audioElement.error ? audioElement.error.code : "unknown");
          console.error("Audio error message:", audioElement.error ? audioElement.error.message : "unknown");
          
          // Fall back to text-to-speech
          console.log("Falling back to text-to-speech");
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.lang = 'kn-IN';
          const voices = window.speechSynthesis.getVoices();
          utterance.voice = voices.find(voice => voice.lang === 'kn-IN') || voices[0];
          utterance.rate = 0.8;
          
          utterance.onend = () => {
            console.log("TTS completed");
            setTimeout(() => {
              isAsking = false;
              console.log("Now accepting input");
              // Restart recognition after question is done
              if (recognition && !isSpeaking) {
                recognition.start();
              }
              resolve();
            }, 500);
          };
          
          utterance.onerror = (event) => {
            console.error("TTS error:", event);
            isAsking = false;
            resolve();
          };
          
          window.speechSynthesis.speak(utterance);
        };
        
        // Try to play the audio
        const playPromise = audioElement.play();
        if (playPromise !== undefined) {
          playPromise.catch(error => {
            console.error("Error playing audio:", error);
            audioElement.onerror(error);
          });
        }
      });
    }

    function startListening() {
      navigator.mediaDevices.getUserMedia({ audio: true, video: true })
        .then(stream => {
          audioStream = stream;
          document.getElementById('video').srcObject = stream;

          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          dataArray = new Uint8Array(analyser.fftSize);

          source = audioContext.createMediaStreamSource(stream);
          source.connect(analyser);
          visualize();

          if (recognition) {
            try {
              recognition.start();
              console.log("Speech recognition started...");
              isSpeaking = true;
              document.getElementById('micBtn').textContent = 'üî¥';
            } catch (error) {
              console.error("Error starting recognition:", error);
              appendMessage("‡≤∏‡≥ç‡≤™‡≥Ä‡≤ö‡≥ç ‡≤∞‡≥Ü‡≤ï‡≤ó‡≥ç‡≤®‡≤ø‡≤∑‡≤®‡≥ç ‡≤Ü‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≥Å‡≤µ‡≤≤‡≥ç‡≤≤‡≤ø ‡≤¶‡≥ã‡≤∑: " + error.message, 'error');
            }
          }
        })
        .catch(err => {
          console.error("Error accessing media devices:", err);
          if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
            appendMessage("‡≤Æ‡≥à‡≤ï‡≥ç‡≤∞‡≥ã‡≤´‡≥ã‡≤®‡≥ç ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤ï‡≥ç‡≤Ø‡≤æ‡≤Æ‡≤∞‡≤æ‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤™‡≥ç‡≤∞‡≤µ‡≥á‡≤∂ ‡≤®‡≤ø‡≤∞‡≤æ‡≤ï‡≤∞‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤¨‡≥ç‡≤∞‡≥å‡≤∏‡≤∞‡≥ç ‡≤∏‡≥Ü‡≤ü‡≥ç‡≤ü‡≤ø‡≤Ç‡≤ó‡≥ç‚Äå‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤™‡≥ç‡≤∞‡≤µ‡≥á‡≤∂‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤Ö‡≤®‡≥Å‡≤Æ‡≤§‡≤ø‡≤∏‡≤ø ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.", 'error');
          } else {
            appendMessage("‡≤Æ‡≥à‡≤ï‡≥ç‡≤∞‡≥ã‡≤´‡≥ã‡≤®‡≥ç ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤ï‡≥ç‡≤Ø‡≤æ‡≤Æ‡≤∞‡≤æ‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤™‡≥ç‡≤∞‡≤µ‡≥á‡≤∂‡≤ø‡≤∏‡≤≤‡≥Å ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≥Å‡≤µ‡≤æ‡≤ó ‡≤¶‡≥ã‡≤∑ ‡≤∏‡≤Ç‡≤≠‡≤µ‡≤ø‡≤∏‡≤ø‡≤¶‡≥Ü: " + err.message, 'error');
          }
        });
    }

    function stopListening() {
      if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
      }
      if (recognition) {
        try {
          recognition.stop();
          console.log("Speech recognition stopped...");
          isSpeaking = false;
          document.getElementById('micBtn').textContent = 'üéôÔ∏è';
        } catch (error) {
          console.error("Error stopping recognition:", error);
        }
      }
      if (audioElement) {
        audioElement.pause();
        audioElement.currentTime = 0;
      }
      cancelAnimationFrame(animationId);
    }

    async function calculateCreditScore(responses, voiceConfidenceScores) {
      let baseScore = 0;
      responses.forEach((response, index) => {
        response = response.toLowerCase();
        switch (index) {
          case 0: // Full name
            baseScore += response.length > 5 ? 10 : 5;
            break;
          case 1: // Employment status
            baseScore += response.includes('employed') || response.includes('self-employed') ? 10 : 5;
            break;
          case 2: // Annual income
            const income = parseFloat(response.replace(/[^0-9.]/g, ''));
            baseScore += income > 0 ? Math.min(10, income / 10000) : 0;
            break;
          case 3: // Existing loans or debts
            baseScore += response.includes('no') ? 10 : 5;
            break;
          case 4: // Credit score
            const creditScore = parseInt(response);
            baseScore += creditScore > 300 ? Math.min(10, (creditScore - 300) / 50) : 0;
            break;
          case 5: // Purpose of credit
            baseScore += response.length > 10 ? 10 : 5;
            break;
          case 6: // Credit amount requested
            const amount = parseFloat(response.replace(/[^0-9.]/g, ''));
            baseScore += amount > 0 ? Math.min(10, amount / 10000) : 0;
            break;
          case 7: // Own or rent residence
            baseScore += response.includes('own') ? 10 : 5;
            break;
          case 8: // Duration at current job
            const duration = parseInt(response);
            baseScore += duration > 0 ? Math.min(10, duration / 2) : 0;
            break;
          case 9: // Additional income
            baseScore += response.includes('yes') ? 10 : 5;
            break;
        }
      });
      
      // Calculate voice confidence influence
      const averageVoiceConfidence = voiceConfidenceScores.length > 0 
        ? voiceConfidenceScores.reduce((a, b) => a + b, 0) / voiceConfidenceScores.length 
        : 0.5;
      
      // Voice multiplier: higher confidence = higher multiplier
      const voiceMultiplier = 0.8 + (averageVoiceConfidence * 0.4); // Range: 0.8 to 1.2
      
      // Final score with voice influence
      const finalScore = Math.min(100, Math.max(0, baseScore * voiceMultiplier));
      
      return {
        baseScore: Math.min(100, Math.max(0, baseScore)),
        voiceConfidence: averageVoiceConfidence,
        voiceMultiplier: voiceMultiplier,
        finalScore: finalScore
      };
    }

    async function askNextQuestion() {
      if (currentQuestionIndex < questions.length) {
        const question = `‡≤™‡≥ç‡≤∞‡≤∂‡≥ç‡≤®‡≥Ü ${currentQuestionIndex + 1}: ${questions[currentQuestionIndex]}`;
        appendMessage(question, 'bot');
        console.log("Starting to ask question:", question);
        
        if (recognition && isSpeaking) {
          recognition.stop();
        }
        
        try {
          console.log("Attempting to speak question...");
          await speakQuestion(questions[currentQuestionIndex]);
          console.log("Finished speaking question");
        } catch (error) {
          console.error("Error speaking question:", error);
        }
        
        if (recognition && isSpeaking) {
          recognition.start();
        }
      } else {
        appendMessage("‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø‡≤Æ‡≤æ‡≤™‡≤®‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≥Ç‡≤∞‡≥ç‡≤£‡≤ó‡≥ä‡≤≥‡≤ø‡≤∏‡≤ø‡≤¶‡≤ï‡≥ç‡≤ï‡≤æ‡≤ó‡≤ø ‡≤ß‡≤®‡≥ç‡≤Ø‡≤µ‡≤æ‡≤¶‡≤ó‡≤≥‡≥Å. ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤â‡≤§‡≥ç‡≤§‡≤∞‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤¶‡≤æ‡≤ñ‡≤≤‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü.", 'bot');
        stopListening();
        
        // Calculate credit score with voice analysis
        const scoreResult = await calculateCreditScore(responses, voiceConfidenceScores);
        console.log("Responses:", responses, "Score Result:", scoreResult);
        
        // Store all score components
        sessionStorage.setItem('finalScore', scoreResult.finalScore);
        sessionStorage.setItem('baseScore', scoreResult.baseScore);
        sessionStorage.setItem('voiceConfidence', scoreResult.voiceConfidence);
        sessionStorage.setItem('voiceMultiplier', scoreResult.voiceMultiplier);
        sessionStorage.setItem('assessmentResponses', JSON.stringify(responses));
        
        // Add View Results button
        const chatInputSection = document.getElementById('chatInputSection');
        chatInputSection.innerHTML = '<button id="viewResultsBtn" class="action-btn">‡≤´‡≤≤‡≤ø‡≤§‡≤æ‡≤Ç‡≤∂‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤µ‡≥Ä‡≤ï‡≥ç‡≤∑‡≤ø‡≤∏‡≤ø</button>';
        document.getElementById('viewResultsBtn').addEventListener('click', () => {
          const aadhaarNumber = sessionStorage.getItem('aadhaarNumber');
          if (aadhaarNumber) {
            sessionStorage.setItem('aadhaarNumber', aadhaarNumber);
          }
          window.location.href = 'results.html?lang=kn';
        });
      }
    }

    if (recognition) {
      recognition.onresult = function(event) {
        if (isAsking) {
          console.log("Question is being asked, ignoring speech input");
          return;
        }
        
        let interimTranscript = '';
        let finalTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }

        if (finalTranscript && lastTranscript !== finalTranscript) {
          appendMessage(finalTranscript, 'user');
          responses[currentQuestionIndex] = finalTranscript;
          lastTranscript = finalTranscript;
          
          // Start voice recording for analysis
          startVoiceRecording();
          
          // Stop recording after a short delay and analyze
          setTimeout(async () => {
            const confidenceScore = await stopVoiceRecording();
            console.log(`Question ${currentQuestionIndex + 1} voice confidence: ${confidenceScore}`);
            
            currentQuestionIndex++;
            lastTranscript = '';
            setTimeout(askNextQuestion, 1000);
          }, 2000); // Record for 2 seconds
        }
      };

      recognition.onerror = function(event) {
        console.error("Speech recognition error:", event.error);
        appendMessage("‡≤∏‡≥ç‡≤™‡≥Ä‡≤ö‡≥ç ‡≤∞‡≥Ü‡≤ï‡≤ó‡≥ç‡≤®‡≤ø‡≤∑‡≤®‡≥ç ‡≤¶‡≥ã‡≤∑: " + event.error, 'error');
        isSpeaking = false;
      };

      recognition.onend = function() {
        console.log("Speech recognition ended.");
        if (isSpeaking && currentQuestionIndex < questions.length) {
          setTimeout(() => {
            recognition.start();
          }, 500);
        }
      };
    }

    function appendMessage(text, sender) {
      const chatContainer = document.getElementById('chatContainer');
      const msg = document.createElement('div');
      msg.classList.add('chat-message', sender + '-message');
      msg.innerText = text;
      chatContainer.appendChild(msg);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function handleTextInput() {
      const input = document.getElementById('chatInput').value.trim();
      if (!input || currentQuestionIndex >= questions.length) return;
      appendMessage(input, 'user');
      responses[currentQuestionIndex] = input;
      currentQuestionIndex++;
      document.getElementById('chatInput').value = '';
      lastTranscript = '';
      setTimeout(askNextQuestion, 1000);
    }

    const micBtn = document.getElementById('micBtn');
    const rehearBtn = document.getElementById('rehearBtn');
    const chatContainer = document.getElementById('chatContainer');
    const chatInput = document.getElementById('chatInput');

    micBtn.addEventListener('click', () => {
      if (!audioStream) {
        startListening();
        setTimeout(askNextQuestion, 1000);
      } else {
        stopListening();
      }
    });

    rehearBtn.addEventListener('click', () => {
      if (currentQuestionIndex < questions.length) {
        const question = `‡≤™‡≥ç‡≤∞‡≤∂‡≥ç‡≤®‡≥Ü ${currentQuestionIndex + 1}: ${questions[currentQuestionIndex]}`;
        appendMessage("‡≤™‡≥Å‡≤®‡≤∞‡≤æ‡≤µ‡≤∞‡≥ç‡≤§‡≤®‡≥Ü: " + question, 'bot');
        speakQuestion(questions[currentQuestionIndex]).catch(error => {
          console.error("Error replaying question:", error);
          appendMessage("‡≤™‡≥ç‡≤∞‡≤∂‡≥ç‡≤®‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≥Å‡≤®‡≤∞‡≤æ‡≤µ‡≤∞‡≥ç‡≤§‡≤ø‡≤∏‡≥Å‡≤µ‡≤≤‡≥ç‡≤≤‡≤ø ‡≤¶‡≥ã‡≤∑ - ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø", 'error');
        });
      }
    });

    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        handleTextInput();
      }
    });

    // Start the assessment when the page loads
    window.addEventListener('load', () => {
      const introScreen = document.querySelector('.intro-screen');
      introScreen.addEventListener('animationend', () => {
        introScreen.style.display = 'none';
        const mainContainer = document.querySelector('.main-container');
        mainContainer.style.opacity = 1;
        // Start asking questions after intro screen fades out
        setTimeout(askNextQuestion, 1000);
      });
    });
  </script>
</body>
</html>